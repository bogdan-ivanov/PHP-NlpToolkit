<?phpnamespace NlpToolkit;use \RecursiveIteratorIterator;use \RecursiveArrayIterator;/** * Based on: Peter Norvig, "How to Write a Spelling Corrector", http://norvig.com/spell-correct.html */class SpellChecker{	const ALPHABET = "abcdefghijklmnopqrstuvwxyz";		private $dict = array();	public function __construct($spellingFilePath=null){		if (!$spellingFilePath){			$spellingFilePath = dirname(__FILE__) . "/resources/en_spelling.txt";		}				$fh = fopen($spellingFilePath, 'r');		while($line = fgets($fh)) {			$chunks = explode(' ', $line);			$word = $chunks[0];			$cnt = intval($chunks[1]);			$this->dict[$word] = $cnt;		}		fclose($fh);	}	/**	 * Returns the given list of words filtered by known words.	 */	protected function __known($words=array()){		$result = array();		foreach($words as $word){			if(isset($this->dict[$word])){				$result[] = $word;			}		}		return $result;	}	/**	 * Returns a set of words with edit distance 1 from the given word.	 */	public function __edit1($word){		$split = array();		$wordLength = strlen($word);		for($i = 0; $i <= strlen($word); $i++){			$split[] = array(substr($word, 0, $i), $i < $wordLength ? substr($word, $i, $wordLength) : "");		}				$delete = array_filter(array_map(function($split){			$start = $split[0];			$stop = $split[1];			if(!$stop)				return null;			return $start . substr($stop, 1, strlen($stop));		}, $split), function($entry){ return $entry; });				$transpose = array_filter(array_map(function($split){			$start = $split[0];			$stop = $split[1];			if(strlen($stop) <= 1){				return null;			}			return $start . $stop[1] . $stop[0] . substr($stop, 2);		}, $split), function($entry){ return $entry; });				$replace = array_filter(array_map(function($split){			$start = $split[0];			$stop = $split[1];			if(!$stop)				return null;			$results = array();			foreach(str_split($this::ALPHABET) as $letter){				$results[] = $start . $letter . substr($stop, 1);			}			return $results;		}, $split), function($entry){ return $entry; });				$replace = iterator_to_array(new RecursiveIteratorIterator(new RecursiveArrayIterator($replace)), false);				$insert = array_filter(array_map(function($split){			$start = $split[0];			$stop = $split[1];			$results = array();			foreach(str_split($this::ALPHABET) as $letter){				$results[] = $start . $letter . $stop;			}			return $results;		}, $split), function($entry){ return $entry; });				$insert = iterator_to_array(new RecursiveIteratorIterator(new RecursiveArrayIterator($insert)), false);				return array_unique(array_merge($delete, $transpose, $replace, $insert));	}	/**	 * Returns a set of words with edit distance 2 from the given word	 */	public function __edit2($word){		$result = array();		foreach($this->__edit1($word) as $e1){			foreach($this->__edit1($e1) as $e2){				if(isset($this->dict[$e2]))					$result[] = $e2;			}		}		return array_unique($result);	}	/**	 * Return a list of (word, confidence) spelling corrections for the given word,	 * based on the probability of known words with edit distance 1-2 from the given word.	 */	public function suggest($word){		$word = strtolower($word);		if (strlen($word) == 1)			return array(array('word' => $word, 'confidence' => 1.0));					if (in_array($word, array(',', '.', '!', '?', '...')))			return array(array('word' => $word, 'confidence' => 1.0));				if (! trim($word))			return array(array('word' => $word, 'confidence' => 1.0));					if (is_numeric($word))			return array(array('word' => $word, 'confidence' => 1.0));					$candidates = $this->__known(array($word));		if(!$candidates)			$candidates = $this->__known($this->__edit1($word));		if(!$candidates)			$candidates = $this->__known($this->__edit2($word));		if(!$candidates)			$candidates = array($word);					$candidates = array_map(function($candidate){			if (isset($this->dict[$candidate]))				return array('word' => $candidate, 'confidence' => (float)$this->dict[$candidate]);			return array('word' => $candidate, 'confidence' => 0.0);		}, $candidates);				$s = array_sum(array_map(function($a){ return $a['confidence'];}, $candidates));		if (! $s)			$s = 1.0;		$candidates = array_map(function($a) use ($s) { 			return array('word' => $a['word'], 'confidence' => $a['confidence'] / $s);		}, $candidates);		uasort($candidates, function($a, $b){ return ($a['confidence'] < $b['confidence']) ? -1 : 1; });		return array_reverse($candidates);	}}?>